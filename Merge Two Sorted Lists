Authour: Nahor Yirgaalem
Date: July 13th, 2022
Time complexity: O(n)
Space complexity: O(n)

/**
Starts with both heads of the list and uses a user created ListNode that will be used to keep track of where we are currently in the order of the two lists. The program
compares the two nodes values, that with the lesser value is assigned to curr's next and we go to that list nodes 'next' node. We then do curr = curr.next, which takes us 
too the node we just assigned curr.next too and we repeat this until either list 1 or list 2 are finished. Once they are finished, we check which of the two lists are 
incomplete (assuming one is) and add the assign the rest of that list to curr.next.
*/

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode curr = new ListNode();
        ListNode head = curr;
        
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                head.next = list1;
                list1 = list1.next;
            }
            else{
                head.next = list2;
                list2 = list2.next;
            }            
            head = head.next;
        }
        
        if(list1 != null){
            head.next = list1;
            list1 = list1.next;
        }
        
        else if(list2 != null){
            head.next = list2;
            list2 = list2.next;
        }
        
        return curr.next;   

    }
}
